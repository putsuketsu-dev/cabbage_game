<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Â∞èÈ´òÈ∫óÔºöÊà∞È¨•ÂÆåÂÖ®ÈÄ≤ÂåñÁâà</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Microsoft JhengHei', sans-serif;
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
        }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px; 
            aspect-ratio: 16/10;
            background: #87CEEB; 
            overflow: hidden;
            box-sizing: border-box; 
        }
        
        /* === ÊâãÊ©üÊ©´ÂêëÈÅäÁé©Ê®°Âºè === */
        @media (orientation: landscape) and (max-height: 500px) {
            html, body {
                height: 105vh !important; 
                overflow-y: scroll !important;
                overflow-x: scroll !important;
                min-width: 105vw !important; 
            }
            #gameContainer {
                position: relative;
                top: 0; 
                left: 50%;
                transform: translateX(-50%); 
                margin-top: 10px;
                width: min(100vw, calc(100vh * 1.6));
                height: min(100vh, calc(100vw / 1.6));
                max-width: none; 
                aspect-ratio: 16 / 10;
                border-radius: 0; 
            }
            canvas { border-radius: 0; }
        }
        
        /* === Fullscreen API Ê®£Âºè === */
        #gameContainer:fullscreen, #gameContainer:-webkit-full-screen, #gameContainer:-moz-full-screen, #gameContainer:-ms-fullscreen {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            aspect-ratio: 16 / 10 !important;
            width: min(100vw, calc(100vh * 1.6)) !important;
            height: min(100vh, calc(100vw / 1.6)) !important;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px; 
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            z-index: 5;
        }
        #controls {
            position: absolute;
            bottom: 0px;
            left: 0;
            width: 100%;
            height: 120px;
            pointer-events: none; 
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }
        
        /* === ÊñπÂêëÈçµË®≠ÂÆö === */
        .control-group {
            pointer-events: auto; 
            position: relative;
            width: 90px; 
            height: 90px;
            transform: translateY(25px);
        }
        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px; 
            color: rgba(255, 255, 255, 0.7);
            touch-action: manipulation;
            width: 30px; 
            height: 30px; 
        }
        .btn:active, .btn.pressed { background: rgba(255, 215, 0, 0.4); }
        
        #btn-up { top: 0; left: 30px; }
        #btn-down { bottom: 0; left: 30px; }
        #btn-left { top: 30px; left: 0; }
        #btn-right { top: 30px; right: 0; }

        #btn-fire {
            bottom: 30px; right: 10px; width: 63px; height: 63px;
            background-color: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 215, 0, 0.5);
            background-size: cover; background-position: center; background-repeat: no-repeat;
            display: flex; justify-content: center; align-items: center;
            font-size: 12px; color: #FFD700; text-align: center; line-height: 1.2;
            --progress: 0%; 
            background-image: radial-gradient(closest-side, rgba(0,0,0,0.5) 79%, transparent 80% 100%),
                              conic-gradient(#00FFFF var(--progress), rgba(255,255,255,0.2) 0);
            border: 4px solid rgba(255,255,255,0.3);
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            transition: border-color 0.3s;
            transform: translateY(15px);
        }
        #btn-fire::after {
            content: ''; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 75%; height: 75%;
            background-image: var(--icon-url); background-size: contain;
            background-position: center; background-repeat: no-repeat;
            pointer-events: none; z-index: 2;
        }
        #btn-fire.charged {
            border-color: #00FFFF; box-shadow: 0 0 20px #00FFFF; animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1) translateY(15px); } 
            50% { transform: scale(1.05) translateY(15px); } 
            100% { transform: scale(1) translateY(15px); }
        }
        #btn-fire:active, #btn-fire.pressed { transform: scale(0.95) translateY(15px); }
        
        .skill-text {
            position: absolute; color: #FFD700; font-size: 40px; font-weight: 900;
            text-shadow: 3px 3px 0 #FF4500, -1px -1px 0 #000; opacity: 0;
            pointer-events: none; width: 100%; text-align: center; top: 30%;
            animation: popUpBig 1.5s ease-out forwards; z-index: 10;
        }
        @keyframes popUpBig {
            0% { opacity: 0; transform: scale(0.5) translateY(0); }
            10% { opacity: 1; transform: scale(1.5) translateY(-20px); }
            80% { opacity: 1; transform: scale(1) translateY(-20px); }
            100% { opacity: 0; transform: scale(1) translateY(-50px); }
        }
        
        #gameOverScreen, #startScreen {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9);
            color: white; padding: 20px; border-radius: 15px; text-align: center;
            border: 3px solid #FF4500; z-index: 30; width: 80%;
        }
        #startScreen {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-color: #00FFFF;
        }
        
        button {
            background: #FFD700; border: none; padding: 10px 30px; font-size: 20px;
            cursor: pointer; border-radius: 50px; margin-top: 20px; font-weight: bold; color: #333;
        }
        #bossWarning {
            display: none; position: absolute; top: 20%; width: 100%; text-align: center;
            color: red; font-size: 40px; font-weight: bold; text-shadow: 2px 2px white;
            animation: blink 0.5s infinite; z-index: 10;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <div id="ui">
        <div>HP: <span id="hpDisplay">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        <div>Lv: <span id="level">1</span> | <span id="nextLevel">ÈÇÑÈúÄÊìäÈÄÄ: 20</span></div>
        <div>Score: <span id="score">0</span></div>
        <div style="font-size: 12px; color: #FFD700; margin-top: 5px;">üí° ÈõôÊìä=Â§ßÁµï(1.5ÂÄçÂÇ∑) | Èï∑Êåâ=Èò≤Á¶¶</div>
        <div id="fullscreenBtn" style="cursor: pointer; color: #00FFFF; font-size: 14px; font-weight: bold; margin-top: 5px; pointer-events: auto;">[ÂÖ®Ëû¢ÂπïÊ®°Âºè]</div>
    </div>
    
    <div id="bossWarning">‚ö†Ô∏è È≠îÁéã‰æÜË•≤ ‚ö†Ô∏è</div>
    <div id="skillContainer"></div>

    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <div id="controls">
        <div class="control-group">
            <div class="btn" id="btn-up" data-key="ArrowUp">‚Üë</div>
            <div class="btn" id="btn-down" data-key="ArrowDown">‚Üì</div>
            <div class="btn" id="btn-left" data-key="ArrowLeft">‚Üê</div>
            <div class="btn" id="btn-right" data-key="ArrowRight">‚Üí</div>
        </div>
        <div class="control-group">
            <div class="btn" id="btn-fire" data-key="Space"></div>
        </div>
    </div>

    <div id="startScreen">
        <h1 style="color: #00FFFF; text-shadow: 2px 2px 0 #000;">Â∞èÈ´òÈ∫óÂÜíÈö™</h1>
        <p>Ê∫ñÂÇôÂ•Ω‰Ω†ÁöÑÊâãÊåáÔºÅ</p>
        <button onclick="startGame()">ÈñãÂßãÈÅäÊà≤</button>
    </div>

    <div id="gameOverScreen">
        <h1 id="endTitle">ÈÅäÊà≤ÁµêÊùü</h1>
        <p>ÂàÜÊï∏: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Èáç‰æÜ</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const nextLevelEl = document.getElementById('nextLevel');
    const hpDisplayEl = document.getElementById('hpDisplay');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startScreen = document.getElementById('startScreen');
    const endTitle = document.getElementById('endTitle');
    const finalScoreEl = document.getElementById('finalScore');
    const bossWarningEl = document.getElementById('bossWarning');
    const skillContainer = document.getElementById('skillContainer');
    const btnFire = document.getElementById('btn-fire');
    const fullscreenBtn = document.getElementById('fullscreenBtn');

    // --- ÂúñÁâáËºâÂÖ• ---
    const BASE_URL = 'https://raw.githubusercontent.com/putsuketsu-dev/Cabbage/main/';
    const imageSources = {
        background: BASE_URL + 'BG.jpg',
        playerRun1: BASE_URL + '‰∏ªËßíËµ∞Ë∑Ø1.png',
        playerRun2: BASE_URL + '‰∏ªËßíËµ∞Ë∑Ø2.png',
        playerAttack: BASE_URL + '‰∏ªËßíÊîªÊìä.png',
        playerBullet: BASE_URL + '‰∏ªËßíÊãõÂºè.png',
        boss1: BASE_URL + 'È≠îÁéã1.png',
        boss2: BASE_URL + 'È≠îÁéã2.png',
        bossUltAnim: BASE_URL + 'È≠îÁéãÈñãÂ§ßÁµï.png',
        bossUltBullet: BASE_URL + 'È≠îÁéãÂ§ßÁµïÊãõ.png',
        minion: BASE_URL + 'Â∞èÊÄ™.png',
        smallBoss: BASE_URL + 'Â∞èÁéã.png',
        superMove: BASE_URL + 'skill.png',
        bossThrow: BASE_URL + 'bthrow.png',
        def1: BASE_URL + 'd1.png',
        def2: BASE_URL + 'd2.png',
        def3: BASE_URL + 'd3.png',
        def4: BASE_URL + 'd4.png',
        def5: BASE_URL + 'd5.png',
        playerUltAttack1: BASE_URL + 'ba1.png', 
        playerUltAttack2: BASE_URL + 'ba2.png' 
    };

    const images = {};
    const imageLoaded = {};

    for (let key in imageSources) {
        images[key] = new Image();
        images[key].crossOrigin = "Anonymous";
        images[key].onload = () => {
            imageLoaded[key] = true;
            if(key === 'playerBullet') {
                btnFire.style.setProperty('--icon-url', `url('${imageSources[key]}')`);
            }
        };
        images[key].onerror = () => { imageLoaded[key] = false; };
        images[key].src = imageSources[key];
    }

    function drawSprite(imgKey, x, y, w, h, fallbackColor, shape='rect', sourceX=0, sourceY=0, sourceW=0, sourceH=0) {
        if (imageLoaded[imgKey]) {
            try {
                if (sourceW > 0 && sourceH > 0) { 
                    ctx.drawImage(images[imgKey], sourceX, sourceY, sourceW, sourceH, x, y, w, h);
                } else {
                    ctx.drawImage(images[imgKey], x, y, w, h);
                }
            } catch(e) {
                drawShape(fallbackColor, x, y, w, h, shape);
            }
        } else {
            drawShape(fallbackColor, x, y, w, h, shape);
        }
    }

    function drawShape(color, x, y, w, h, shape) {
        ctx.fillStyle = color;
        if (shape === 'circle') {
            ctx.beginPath(); ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI * 2); ctx.fill();
        } else {
            ctx.fillRect(x, y, w, h);
        }
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
    }

    // --- ÈÅäÊà≤ÂèÉÊï∏ ---
    let gameRunning = false; 
    let gameStarted = false; 
    let frameCount = 0;
    let score = 0;
    let level = 1;
    const ENEMIES_PER_LEVEL = 20; 
    let enemiesDefeatedInLevel = 0;
    let bossActive = false;
    let bossSpawned = false;
    let pendingLevelUp = false;

    let backgroundOffsetX = 0;
    const targetBackgroundOffsetX = -800; 
    const backgroundScrollSpeed = 4; 

    // ËßíËâ≤
    const player = {
        x: 50, y: 250, width: 160, height: 160, speed: 6, hp: 5, maxHp: 5,
        isInvincible: false, invincibleTimer: 0, isAttacking: false, attackTimer: 0,
        isDefending: false, defenseTimer: 0, charge: 0, maxCharge: 20,
        isStunned: false, stunTimer: 0,
        defenseDuration: 0, guardHitCount: 0,
        isUltAttacking: false, ultAttackTimer: 0 
    };

    const PLAYER_MIN_Y = 200; 
    const PLAYER_MAX_Y = 380; 
    player.y = (PLAYER_MIN_Y + PLAYER_MAX_Y) / 2;

    let bullets = [];
    let bossBullets = [];
    let enemies = [];
    let items = []; 
    let combatTexts = []; 
    
    let enemySpawnRate = 60;
    const BASE_SPAWN_RATE = 35; 
    const RATE_DECREMENT = 10; 

    const bossQuotes = ["Ë¶ÅÂä†ÈÜ¨ÂóéÔºü", "Ê≤íÊúâÂêÉÁ¥†ÈΩÅ", "ÁèæÂú®ÂêÉÂóéÔºü"];
    let bossText = { text: "", timer: 0, x: 0, y: 0 };

    // --- ÊéßÂà∂Á≥ªÁµ± ---

    const keys = {};
    let fireKeyPressed = false;
    let fireKeyTimer = 0;
    let lastFireReleaseTime = 0;

    window.addEventListener('keydown', (e) => {
        keys[e.code] = true;
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
        if (e.code === 'Space' && !fireKeyPressed) {
            fireKeyPressed = true;
            handleFirePress();
        }
    });
    window.addEventListener('keyup', (e) => {
        keys[e.code] = false;
        if (e.code === 'Space') {
            fireKeyPressed = false;
            handleFireRelease();
        }
    });

    const btns = document.querySelectorAll('.btn');
    btns.forEach(btn => {
        const handleStart = (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = true;
            btn.classList.add('pressed');
            if (key === 'Space' && !fireKeyPressed) {
                fireKeyPressed = true;
                handleFirePress();
            }
        };
        const handleEnd = (e) => {
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = false;
            btn.classList.remove('pressed');
            if (key === 'Space') {
                fireKeyPressed = false;
                handleFireRelease();
            }
        };
        btn.addEventListener('touchstart', handleStart);
        btn.addEventListener('touchend', handleEnd);
        btn.addEventListener('mousedown', handleStart);
        btn.addEventListener('mouseup', handleEnd);
    });

    function handleFirePress() {
        if (player.isStunned || !gameRunning || player.isUltAttacking) return; 

        fireKeyTimer = 0;
        let currentTime = new Date().getTime();
        if (currentTime - lastFireReleaseTime < 300 && player.charge >= player.maxCharge) {
            fireSuperMove(); 
            player.isDefending = false; 
            player.isAttacking = false; 
            fireKeyTimer = 999; 
        }
    }

    function handleFireRelease() {
        if (player.isStunned || !gameRunning || player.isUltAttacking) { 
            player.isDefending = false;
            fireKeyTimer = 0;
            player.guardHitCount = 0; 
            return;
        }

        lastFireReleaseTime = new Date().getTime();
        if (fireKeyTimer < 15) { 
            shoot(); 
            player.isAttacking = true;
            player.attackTimer = 15;
        }
        
        player.isDefending = false;
        fireKeyTimer = 0;
        player.guardHitCount = 0; 
    }

    function addCharge(amount = 1) {
        if (player.charge < player.maxCharge) {
            player.charge += amount;
            if(player.charge > player.maxCharge) player.charge = player.maxCharge;
        }
    }

    function updateChargeUI() {
        const pct = (player.charge / player.maxCharge) * 100;
        btnFire.style.setProperty('--progress', pct + '%');
        if (player.charge >= player.maxCharge) {
            btnFire.classList.add('charged');
        } else {
            btnFire.classList.remove('charged');
        }
    }

    function fireSuperMove() {
        player.charge = 0; 
        updateChargeUI(); 
        showSkillText("Â∞èÈ´òÈ∫óÁöÑÂà∂Ë£ÅÔºÅ", player.x, player.y - 50);
        
        player.isUltAttacking = true;
        player.ultAttackTimer = 30; 
        
        player.isDefending = false;
        player.isAttacking = false;

        bullets.push({
            x: player.x + player.width, 
            y: player.y + player.height / 2 - 75, 
            vx: 15, vy: 0,
            width: 300, height: 150, 
            type: 'super', 
            damage: 1.5, 
            piercing: true, 
            life: 100
        });
    }

    function showSkillText(text, x, y) {
        const el = document.createElement('div');
        el.innerText = text;
        el.className = 'skill-text';
        let safeX = Math.min(Math.max(x, 50), 600);
        el.style.left = safeX + 'px';
        el.style.top = '150px'; 
        skillContainer.appendChild(el);
        setTimeout(() => el.remove(), 1500);
    }

    function showCombatText(text, x, y, color="#FFF") {
        combatTexts.push({
            text: text, x: x, y: y, color: color, life: 30
        });
    }

    function shoot() {
        if(player.isDefending || player.isUltAttacking) return; 

        let bulletCount = 1;
        if (level === 2) bulletCount = 3;
        if (level >= 3) bulletCount = 5; 
        let baseSpeed = 12 + (level * 1.5);
        
        const bulletSize = 80 * 1.3; 

        for (let i = 0; i < bulletCount; i++) {
            let vy = 0;
            if (bulletCount > 1) {
                let spreadFactor = 1.5;
                let centerIndex = (bulletCount - 1) / 2;
                vy = (i - centerIndex) * spreadFactor;
            }
            bullets.push({
                x: player.x + player.width - 30, 
                y: player.y + player.height / 2,
                vx: baseSpeed, vy: vy,
                size: bulletSize, 
                color: '#FFFF00',
                damage: 1,
                type: 'normal'
            });
        }
    }

    function playerTakeDamage(damage, options = {}) {
        if (player.isDefending) {
            let hitCount = options.isUltimate ? 3 : 1; 
            player.guardHitCount += hitCount;
            
            if (player.guardHitCount >= 5) { 
                player.isDefending = false;
                player.isStunned = true;
                player.stunTimer = 60; 
                player.hp -= 1; 
                player.guardHitCount = 0; 
                updateHPUI();
                showCombatText("Á†¥Èò≤!!", player.x + player.width/2, player.y - 20, "red");
            } else {
                showCombatText(`Èò≤Á¶¶ x${hitCount}`, player.x + player.width/2, player.y, "#00BFFF");
            }
            return; 
        }

        if (player.isInvincible || !gameRunning) return;

        // === [‰øÆÊ≠£1] ÊöàÁú©Âà§Êñ∑ÈÇèËºØ ===
        // Â¶ÇÊûúÊ≤íÊúâÈò≤Á¶¶Ôºå‰∏îË¢´È≠îÁéãÂ§ßÁµïÊìä‰∏≠
        if (options.isUltimate) {
            player.isStunned = true;
            player.stunTimer = 60; // ÊöàÁú© 1 Áßí (60 ÂπÄ)
            showCombatText("ÊöàÁú©!", player.x + player.width/2, player.y - 20, "orange");
        }
        // =========================

        player.hp -= damage;
        updateHPUI();
        if (player.hp <= 0) {
            gameOver("Ë¢´Á≤ΩÂ≠êÂ°ûÈ£Ω‰∫Ü...");
        } else {
            player.isInvincible = true;
            player.invincibleTimer = 90; 
        }
    }

    function updateHPUI() {
        let hearts = "";
        for(let i=0; i<player.hp; i++) hearts += "‚ù§Ô∏è";
        for(let i=player.hp; i<player.maxHp; i++) hearts += "üñ§"; 
        hpDisplayEl.innerText = hearts;
    }

    function bossSpeak(x, y) {
        const text = bossQuotes[Math.floor(Math.random() * bossQuotes.length)];
        bossText.text = text;
        bossText.timer = 120; 
        bossText.x = x;
        bossText.y = y - 60;
    }

    function bossAttack(boss) {
        const bossBulletSize = 30 * 1.2; 

        if (boss.phase === 1) {
            if (frameCount % 120 === 0) { 
                bossSpeak(boss.x, boss.y);
                for(let i = -1; i <= 1; i++) {
                    let dx = player.x - boss.x;
                    let dy = player.y - boss.y;
                    let angle = Math.atan2(dy, dx);
                    bossBullets.push({
                        x: boss.x + boss.width / 2, y: boss.y + boss.height / 2,
                        vx: Math.cos(angle + i * 0.25) * 6, vy: Math.sin(angle + i * 0.25) * 6,
                        size: bossBulletSize, 
                        type: 'normal'
                    });
                }
            }
            if (boss.hp <= boss.maxHp * 0.2 && !boss.hasUlted) {
                boss.hasUlted = true; fireUltimate(boss);
            }
        } else if (boss.phase === 2) {
            if (frameCount % 90 === 0) {
                bossSpeak(boss.x, boss.y);
                fireUltimate(boss);
            }
        }
    }

    function fireUltimate(boss) {
        showSkillText("ÊéíÈöäÊìãË∑ØÔºÅ", boss.x - 50, boss.y - 50);
        
        boss.isCasting = true;
        setTimeout(() => boss.isCasting = false, 1500);

        bossBullets.push({
            x: boss.x - 50, y: boss.y, 
            vx: -6, vy: 0, size: 140, 
            type: 'ultimate', rotation: 0, homing: true
        });
    }

    function spawnEnemy() {
        if (bossActive && !bossSpawned) return;

        const SIZE_MULTIPLIER = 1.4;

        if (!bossActive) {
            let enemyType = 'minion';
            let eWidth = 110 * SIZE_MULTIPLIER; 
            let eHeight = 110 * SIZE_MULTIPLIER; 
            let eHp = 1 + Math.floor(level / 1.5);
            
            if (level === 2) {
                if (Math.random() < 0.55) { 
                    enemyType = 'smallBoss'; 
                    eWidth = 130 * SIZE_MULTIPLIER; 
                    eHeight = 130 * SIZE_MULTIPLIER; 
                    eHp = 12; 
                }
            }
            
            const ENEMY_SPAWN_MIN_Y = 180; 
            const ENEMY_SPAWN_MAX_Y = 320; 
            const yRange = ENEMY_SPAWN_MAX_Y - ENEMY_SPAWN_MIN_Y;

            let spawnY = ENEMY_SPAWN_MIN_Y + Math.random() * yRange;
            
            let speedMultiplier = 1.0;
            if (frameCount < 300) speedMultiplier = 0.4;
            else if (frameCount < 900) speedMultiplier = 0.7;
            
            let baseSpeed = (enemyType === 'smallBoss' ? 2 : 3 + (level * 0.8)) * 2 * speedMultiplier;

            enemies.push({
                x: 800, y: spawnY, 
                width: eWidth, height: eHeight,
                speed: baseSpeed,
                hp: eHp, type: enemyType, maxHp: eHp,
                jumpTimer: 0,
                vy: 0
            });
        }
    }

    function triggerBossStage() {
        bossActive = true;
        bossSpawned = false;
        updateUI();
    }

    function realSpawnBoss() {
        bossActive = true; 
        bossSpawned = true;
        
        bossWarningEl.style.display = 'block';
        setTimeout(() => bossWarningEl.style.display = 'none', 3000);

        enemies = []; 
        enemies.push({
            x: 800 - 250, y: 250,
            width: 240, height: 240, 
            speed: 2, hp: 100, maxHp: 100,
            type: 'boss', phase: 1, moveDir: -1, hasUlted: false,
            isCasting: false 
        });
        updateUI();
    }

    function evolveBoss(boss) {
        bossWarningEl.innerText = "‚ö†Ô∏è ÊúÄÁµÇÂΩ¢ÊÖãÈÄ≤Âåñ!!! ‚ö†Ô∏è";
        bossWarningEl.style.display = 'block';
        setTimeout(() => bossWarningEl.style.display = 'none', 2000);
        boss.phase = 2; boss.hp = 150; boss.maxHp = 150;
        boss.width = 240; boss.height = 240; boss.y = 250; 
        boss.isCasting = false; 
        bullets = []; 
    }

    function update() {
        if (gameRunning) {
            
            if (player.isUltAttacking) {
                player.ultAttackTimer--;
                keys['ArrowUp'] = keys['ArrowDown'] = keys['ArrowLeft'] = keys['ArrowRight'] = false;
                player.isAttacking = false;
                player.isDefending = false;

                if (player.ultAttackTimer <= 0) {
                    player.isUltAttacking = false;
                }
            }

            if (player.isDefending) {
                player.defenseDuration++;
            } else { 
                player.defenseDuration = 0;
            }

            if (player.isStunned) {
                player.stunTimer--;
                player.isDefending = false; 
                player.isAttacking = false; 
                if (player.stunTimer <= 0) { 
                    player.isStunned = false;
                    player.guardHitCount = 0; 
                    fireKeyTimer = 0;
                    fireKeyPressed = false;
                    keys['Space'] = false; 
                    document.getElementById('btn-fire').classList.remove('pressed'); 
                }
            } else if (!player.isUltAttacking) { 
                if (fireKeyPressed) {
                    fireKeyTimer++;
                    if (fireKeyTimer >= 15) { 
                        player.isDefending = true; 
                        player.isAttacking = false;
                    }
                }

                if (player.isAttacking) {
                    player.attackTimer--;
                    if (player.attackTimer <= 0) player.isAttacking = false;
                }

                // ÁßªÂãïÊéßÂà∂
                if (keys['ArrowUp']) player.y -= player.speed;
                if (keys['ArrowDown']) player.y += player.speed;
                if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
                if (keys['ArrowRight'] && player.x < canvas.width - player.width) player.x += player.speed;
            }

            if (bossActive && !bossSpawned) {
                if (backgroundOffsetX > targetBackgroundOffsetX) {
                    backgroundOffsetX -= backgroundScrollSpeed;
                } else {
                    backgroundOffsetX = targetBackgroundOffsetX;
                    realSpawnBoss();
                }
            } else if (!bossActive) {
                backgroundOffsetX = 0;
            }

            player.y = Math.min(Math.max(player.y, PLAYER_MIN_Y), PLAYER_MAX_Y);
            player.x = Math.min(Math.max(player.x, 0), canvas.width - player.width);

            if (player.isInvincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) player.isInvincible = false;
            }
            
            if (bossText.timer > 0) bossText.timer--;
            if (pendingLevelUp) { performLevelUp(); pendingLevelUp = false; }
            if (!bossActive && !pendingLevelUp) {
                enemySpawnRate = Math.max(5, (BASE_SPAWN_RATE - (level * RATE_DECREMENT)) / 1.5); 
                if (frameCount % Math.floor(enemySpawnRate) === 0) spawnEnemy();
            }

            for (let i = items.length - 1; i >= 0; i--) {
                let item = items[i];
                item.x -= item.speed; 
                
                let itemHitbox = {
                    x: item.x + 15, y: item.y + 15,
                    width: 20, height: 20
                };
                
                if (checkRectCollision(player, itemHitbox)) {
                    if (item.type === 'heart') {
                        if(player.hp < player.maxHp) { player.hp++; updateHPUI(); }
                    } else if (item.type === 'blackHeart') {
                        player.hp -= 2;
                        updateHPUI();
                        showCombatText("-2", player.x, player.y, "black");
                        if (player.hp <= 0) gameOver("Ë™§È£üÈªëËâ≤ÊÑõÂøÉ...");
                    }
                    items.splice(i, 1); continue;
                }
                if (item.x < -50) items.splice(i, 1);
            }

            for(let i = combatTexts.length - 1; i >= 0; i--) {
                let t = combatTexts[i];
                t.y -= 1; t.life--;
                if(t.life <= 0) combatTexts.splice(i, 1);
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.x += b.vx; b.y += b.vy; 
                if (b.type !== 'super' && (b.x > canvas.width || b.y < 0 || b.y > canvas.height)) {
                    bullets.splice(i, 1);
                } else if (b.type === 'super') {
                    b.life--;
                    if (b.life <= 0 || b.x > canvas.width) bullets.splice(i, 1);
                }
            }
            
            for (let i = bossBullets.length - 1; i >= 0; i--) {
                let b = bossBullets[i];
                b.x += b.vx; b.y += b.vy;
                if (b.type === 'ultimate') {
                    b.rotation -= 0.2;
                    if (b.homing) {
                        let dy = player.y - b.y;
                        if (dy > 0) b.vy += 0.15; else b.vy -= 0.15;
                        if (b.vy > 3) b.vy = 3; if (b.vy < -3) b.vy = -3;
                    }
                }
                let hitBoxSize = b.type === 'ultimate' ? b.size * 0.7 : b.size * 0.8; 
                let playerHitbox = {x: player.x + 10, y: player.y + 10, width: player.width - 20, height: player.height - 20};
                let bulletHitbox = {x: b.x - hitBoxSize/2, y: b.y - hitBoxSize/2, width: hitBoxSize, height: hitBoxSize};

                if (checkRectCollision(bulletHitbox, playerHitbox)) {
                    
                    let isUltimateHit = b.type === 'ultimate';

                    playerTakeDamage(1, {isUltimate: isUltimateHit}); 
                    
                    bossBullets.splice(i, 1); 
                    i--; 

                } else if (b.x < -200 || b.y < -100 || b.y > canvas.height + 100) {
                    bossBullets.splice(i, 1);
                    i--; 
                }
            }

            let uiDirty = false;
            let chargeDirty = false;

            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];
                if (e.type === 'boss') {
                    if (e.x > canvas.width - 250) e.x -= e.speed;
                    let moveSpeed = e.phase === 2 ? e.speed * 2 : e.speed;
                    e.y += moveSpeed * e.moveDir;
                    if (e.y < 250 || e.y > 350) e.moveDir *= -1;
                    bossAttack(e);
                    bossText.x = e.x; bossText.y = e.y - 60; 
                } else { 
                    if (e.type === 'smallBoss') {
                        e.jumpTimer = (e.jumpTimer || 0) + 1;
                        if (e.jumpTimer < 60) { 
                            e.x -= 0.5;
                        } else if (e.jumpTimer < 80) { 
                            e.x -= e.speed * 3; 
                            if (e.jumpTimer === 60) { 
                                e.vy = (Math.random() - 0.5) * 4; 
                            }
                            e.y += e.vy;
                        } else {
                            e.jumpTimer = 0;
                        }
                    } else {
                        e.x -= e.speed;
                    }
                }

                for (let j = bullets.length - 1; j >= 0; j--) {
                    let b = bullets[j];
                    
                    let bRect = b.type === 'super' 
                        ? {x: b.x, y: b.y, width: b.width, height: b.height} 
                        : {x: b.x - b.size/2 + b.size*0.1, y: b.y - b.size/2 + b.size*0.1, width: b.size * 0.8, height: b.size * 0.8}; 

                    let eRect = {x: e.x + 10, y: e.y + 10, width: e.width - 20, height: e.height - 20};

                    if (checkRectCollision(bRect, eRect)) {
                        
                        let defenseChance = (e.type === 'boss' && b.type === 'super') ? 0.6 : 0.3; 
                        
                        if (e.type === 'boss' && Math.random() < defenseChance) {
                            showCombatText("Èò≤Á¶¶!", e.x + e.width/2, e.y, "#00FFFF");
                            if (!b.piercing) bullets.splice(j, 1);
                        } else {
                            e.hp -= (b.damage || 1);
                            if (e.type === 'boss') { addCharge(); chargeDirty = true; }
                            if (!b.piercing) bullets.splice(j, 1);

                            if (e.hp <= 0) {
                                if (e.type === 'boss') {
                                    if (e.phase === 1) evolveBoss(e); else gameWin();
                                } else {
                                    addCharge(); chargeDirty = true;
                                    if (e.type === 'smallBoss') {
                                        if (Math.random() < 0.5) {
                                            items.push({
                                                x: e.x, y: e.y, width: 40, height: 40, speed: 2, type: 'heart'
                                            });
                                        } else if (Math.random() < 0.1) { 
                                            items.push({
                                                x: e.x, y: e.y, width: 40, height: 40, speed: 2, type: 'blackHeart'
                                            });
                                        }
                                    }
                                    score += 10; enemiesDefeatedInLevel++;
                                    if (enemiesDefeatedInLevel >= ENEMIES_PER_LEVEL) pendingLevelUp = true;
                                    enemies.splice(i, 1);
                                    uiDirty = true;
                                    
                                    break; 
                                }
                                uiDirty = true;
                            }
                        }
                        if (!b.piercing) break; 
                    }
                }
                
                if (gameRunning && enemies[i]) {
                    if (checkRectCollision(
                        {x: e.x + 10, y: e.y + 10, width: e.width - 20, height: e.height - 20},
                        {x: player.x + 10, y: player.y + 10, width: player.width - 20, height: player.height - 20}
                    )) {
                        playerTakeDamage(1);
                        if(e.type !== 'boss') enemies.splice(i, 1);
                        uiDirty = true;
                    }
                }
                if (enemies[i] && enemies[i].x + enemies[i].width < 0) enemies.splice(i, 1);
            }

            if (uiDirty) updateUI();
            if (chargeDirty) updateChargeUI();

            frameCount++;
        }
        requestAnimationFrame(draw);
    }
    
    function checkRectCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    function performLevelUp() { 
        level++; 
        enemiesDefeatedInLevel = 0; 
        
        if (level === 3) {
            triggerBossStage();
        } else if (level > 3) {
            if (player.hp < player.maxHp) player.hp++; updateHPUI(); 
        }
        updateUI(); 
    }

    function updateUI() {
        scoreEl.innerText = score; updateHPUI();
        if (bossActive) {
            if (bossSpawned) {
                if (enemies.length > 0 && enemies[0].phase === 2) { levelEl.innerText = "FINAL"; nextLevelEl.innerText = "Ê¥ª‰∏ãÂéª"; }
                else { levelEl.innerText = "BOSS"; nextLevelEl.innerText = "ÊâìÂÄí‰ªñ"; }
            } else { levelEl.innerText = "WARN"; nextLevelEl.innerText = "Êé•Ëøë‰∏≠..."; }
        } else { levelEl.innerText = level; nextLevelEl.innerText = "ÈÇÑÈúÄ: " + (ENEMIES_PER_LEVEL - enemiesDefeatedInLevel); }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Áπ™Ë£ΩËÉåÊôØ (1600x500 ÂéüÂúñÔºåÂπ≥ÁßªÁπ™Ë£Ω)
        if (imageLoaded['background']) {
            try {
                ctx.drawImage(
                    images['background'], 
                    -backgroundOffsetX, 
                    0, 
                    canvas.width, 
                    canvas.height,
                    0, 
                    0, 
                    canvas.width, 
                    canvas.height
                );
            } catch(e) {
                drawFallbackBackground();
            }
        } else {
            drawFallbackBackground();
        }

        if (bossText.timer > 0) {
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 3; ctx.textAlign = "center";
            ctx.strokeText(bossText.text, bossText.x + 90, bossText.y);
            ctx.fillText(bossText.text, bossText.x + 90, bossText.y);
        }

        // Áé©ÂÆ∂
        if (!player.isInvincible || Math.floor(frameCount / 5) % 2 === 0) {
            let imgKey;
            
            if (player.isUltAttacking) {
                // Â§ßÁµïÊãõÊñΩÊîæÊôÇÔºåÂàáÊèõÂãï‰Ωú (ÂâçÂçäÊÆµÁî®1ÔºåÂæåÂçäÊÆµÁî®2)
                imgKey = (player.ultAttackTimer > 15) ? 'playerUltAttack1' : 'playerUltAttack2';
            } else if (player.isAttacking) {
                imgKey = 'playerAttack';
            } else if (player.isMoving || (bossActive && !bossSpawned)) { // [‰øÆÊ≠£2] Âä†ÂÖ•ËΩâÂ†¥Âº∑Âà∂Ëµ∞Ë∑ØÈÇèËºØ
                imgKey = (Math.floor(frameCount / 8) % 2 === 0) ? 'playerRun1' : 'playerRun2';
            } else {
                imgKey = 'playerRun1'; 
            }

            // ÊöàÁú©ÊôÇËÆäÁÅ∞
            if (player.isStunned) {
                ctx.save();
                ctx.filter = 'grayscale(100%)'; 
                drawSprite(imgKey, player.x, player.y, player.width, player.height, '#32CD32');
                ctx.restore();
                
                // Áï´ÊöàÁú©Á¨¶Ëôü
                ctx.font = "30px Arial";
                ctx.fillStyle = "yellow";
                ctx.fillText("üí´", player.x + player.width/2 - 15, player.y - 10);
            } else {
                drawSprite(imgKey, player.x, player.y, player.width, player.height, '#32CD32');
            }
            
            if (player.isDefending) {
                let shieldImgKey = 'def1';
                let duration = player.defenseDuration;
                // Á∞°ÂñÆÁöÑÈò≤Á¶¶ÂãïÁï´Âæ™Áí∞ (ÊØè5ÂπÄÊèõ‰∏ÄÂºµ)
                let frame = Math.floor(duration / 5) % 5; 
                if (frame === 0) shieldImgKey = 'def1';
                else if (frame === 1) shieldImgKey = 'def2';
                else if (frame === 2) shieldImgKey = 'def3';
                else if (frame === 3) shieldImgKey = 'def4';
                else shieldImgKey = 'def5';

                // Áπ™Ë£ΩÈò≤Á¶¶ÁõæÁâåÂúñÁâá
                drawSprite(shieldImgKey, player.x - 20, player.y - 20, player.width + 40, player.height + 40, 'rgba(0,0,0,0)');
            }
        }
        
        for (let item of items) {
            ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            let icon = item.type === 'blackHeart' ? "üñ§" : "‚ù§Ô∏è";
            ctx.fillText(icon, item.x + item.width/2, item.y + item.height/2);
        }

        // Â≠êÂΩà
        for (let b of bullets) {
            if (b.type === 'super') {
                drawSprite('superMove', b.x, b.y, b.width, b.height, '#00FFFF', 'rect');
            } else {
                drawSprite('playerBullet', b.x - b.size/2, b.y - b.size/2, b.size, b.size, '#FFFF00', 'circle');
            }
        }
        
        // È≠îÁéãÂ≠êÂΩà
        for (let b of bossBullets) {
            if (b.type === 'ultimate') {
                ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);
                drawSprite('bossUltBullet', -b.size/2, -b.size/2, b.size, b.size, '#8B0000');
                ctx.restore();
            } else {
                drawSprite('minion', b.x - b.size/2, b.y - b.size/2, b.size, b.size, '#A52A2A');
            }
        }
        
        // Êïµ‰∫∫
        for (let e of enemies) {
            if (e.type === 'boss') {
                let shake = (e.phase === 2) ? (Math.random() * 6 - 3) : 0;
                let imgKey;
                
                if (e.isCasting && imageLoaded['bossThrow']) { 
                    imgKey = 'bossThrow'; 
                } else if (e.phase === 1) { 
                    imgKey = (Math.floor(frameCount / 15) % 2 === 0) ? 'boss1' : 'boss2'; 
                } else { 
                    imgKey = 'bossUltAnim'; 
                }

                drawSprite(imgKey, e.x + shake, e.y, e.width, e.height, '#800080');
                
                ctx.fillStyle = "white"; ctx.fillRect(e.x, e.y - 30, e.width, 15);
                ctx.fillStyle = e.phase === 2 ? "#800080" : (e.hp <= e.maxHp * 0.3 ? "red" : "orange");
                ctx.fillRect(e.x + 2, e.y - 28, (e.width - 4) * (e.hp / e.maxHp), 11);
            } else if (e.type === 'smallBoss') {
                drawSprite('smallBoss', e.x, e.y, e.width, e.height, '#FF0000');
                ctx.fillStyle = "red"; ctx.fillRect(e.x, e.y - 10, e.width * (e.hp/e.maxHp), 5);
            } else {
                drawSprite('minion', e.x, e.y, e.width, e.height, '#696969');
            }
        }

        for (let t of combatTexts) {
            ctx.font = "bold 20px Arial";
            ctx.fillStyle = t.color;
            ctx.textAlign = "center";
            ctx.fillText(t.text, t.x, t.y);
        }
    }

    function drawFallbackBackground() {
        ctx.fillStyle = '#87CEEB'; 
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 2;
        let offset = backgroundOffsetX % 100; 
        for(let i=offset; i<canvas.width; i+=100) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
        }
    }

    function startGame() {
        startScreen.style.display = 'none';
        uiEl.style.display = 'block';
        controlsEl.style.display = 'flex';
        gameRunning = true;
        gameStarted = true;
        updateUI();
        updateChargeUI();
        setInterval(() => {
            if(gameRunning) requestAnimationFrame(update);
        }, 1000/60); 
    }

    function gameOver(reason) {
        gameRunning = false; endTitle.innerText = reason; finalScoreEl.innerText = score;
        gameOverScreen.style.display = 'block';
    }
    function gameWin() {
        gameRunning = false; endTitle.innerText = "üèÜ ÂÇ≥Â•áË™ïÁîüÔºÅ"; finalScoreEl.innerText = score + 10000;
        gameOverScreen.style.display = 'block';
    }
    function restartGame() {
        score = 0; level = 1; enemiesDefeatedInLevel = 0; bossActive = false; pendingLevelUp = false; bossSpawned = false;
        enemies = []; bullets = []; bossBullets = []; items = []; combatTexts = [];
        player.y = 250; player.x = 50; player.hp = player.maxHp; player.isInvincible = false;
        player.isAttacking = false; player.isDefending = false; player.attackTimer = 0; player.charge = 0;
        player.isStunned = false; player.guardHitCount = 0;
        enemySpawnRate = 60; 
        backgroundOffsetX = 0; 
        gameRunning = true; gameOverScreen.style.display = 'none'; bossWarningEl.style.display = 'none';
        skillContainer.innerHTML = ''; updateUI(); updateChargeUI(); 
    }
    
    // Fullscreen toggle logic
    fullscreenBtn.addEventListener('click', () => {
        const elem = document.getElementById('gameContainer');
        if (!document.fullscreenElement) {
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { 
                elem.webkitRequestFullscreen();
            }
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    });

    // Initial draw to show something before start
    drawFallbackBackground();
    uiEl.style.display = 'none';
    controlsEl.style.display = 'none';
    startScreen.style.display = 'flex';

</script>

</body>
</html>
