<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°é«˜éº—ï¼šæœ€çµ‚å®Œç¾ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Microsoft JhengHei', sans-serif;
            overflow: hidden; 
            touch-action: none; 
            user-select: none; 
        }
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 800px; 
            aspect-ratio: 16/10;
            background: #87CEEB; 
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 10px;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 16px; 
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            z-index: 5;
            display: none; /* åˆå§‹éš±è— */
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 120px;
            pointer-events: none; 
            display: none; /* åˆå§‹éš±è— */
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
        }
        .control-group {
            pointer-events: auto; 
            position: relative;
            width: 150px;
            height: 150px;
        }
        .btn {
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            touch-action: manipulation;
        }
        .btn:active, .btn.pressed {
            background: rgba(255, 215, 0, 0.6); 
        }
        
        #btn-up { top: 0; left: 50px; width: 50px; height: 50px; }
        #btn-down { bottom: 20px; left: 50px; width: 50px; height: 50px; }
        #btn-left { top: 50px; left: 0; width: 50px; height: 50px; }
        #btn-right { top: 50px; right: 0; width: 50px; height: 50px; }

        #btn-fire {
            bottom: 40px;
            right: 10px;
            width: 90px;
            height: 90px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 3px solid #FFD700;
            background-size: cover; 
            background-position: center;
            background-repeat: no-repeat;
            display: flex; 
            justify-content: center; 
            align-items: center;
            font-size: 14px;
            color: #FFD700;
            text-align: center;
            line-height: 1.2;
            --progress: 0%; 
            background-image: radial-gradient(closest-side, rgba(0,0,0,0.5) 79%, transparent 80% 100%),
                              conic-gradient(#00FFFF var(--progress), rgba(255,255,255,0.3) 0);
            border: 4px solid rgba(255,255,255,0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: border-color 0.3s;
        }
        #btn-fire::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 75%;
            height: 75%;
            background-image: var(--icon-url);
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            pointer-events: none;
            z-index: 2;
        }

        #btn-fire.charged {
            border-color: #00FFFF;
            box-shadow: 0 0 20px #00FFFF;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        #btn-fire:active, #btn-fire.pressed {
            transform: scale(0.95);
        }
        
        .skill-text {
            position: absolute;
            color: #FFD700;
            font-size: 40px; 
            font-weight: 900;
            text-shadow: 3px 3px 0 #FF4500, -1px -1px 0 #000;
            opacity: 0;
            pointer-events: none;
            width: 100%;
            text-align: center;
            top: 30%;
            animation: popUpBig 1.5s ease-out forwards;
            z-index: 10;
        }
        @keyframes popUpBig {
            0% { opacity: 0; transform: scale(0.5) translateY(0); }
            10% { opacity: 1; transform: scale(1.5) translateY(-20px); }
            80% { opacity: 1; transform: scale(1) translateY(-20px); }
            100% { opacity: 0; transform: scale(1) translateY(-50px); }
        }
        
        /* ç•«é¢é®ç½©èˆ‡é¸å–® */
        #loadingScreen, #startScreen, #gameOverScreen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }
        
        #startScreen, #gameOverScreen {
            display: none; /* åˆå§‹ç”± JS æ§åˆ¶é¡¯ç¤º */
        }

        #gameOverScreen {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #FF4500;
            width: 80%; height: auto;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 15px;
            padding: 20px;
        }

        button {
            background: #FFD700;
            border: none;
            padding: 10px 30px;
            font-size: 20px;
            cursor: pointer;
            border-radius: 50px;
            margin-top: 20px;
            font-weight: bold;
            color: #333;
        }
        #bossWarning {
            display: none;
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            color: red;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 2px 2px white;
            animation: blink 0.5s infinite;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <div id="ui">
        <div>HP: <span id="hpDisplay">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</span></div>
        <div>Lv: <span id="level">1</span> | <span id="nextLevel">é‚„éœ€æ“Šé€€: 20</span></div>
        <div>Score: <span id="score">0</span></div>
        <div style="font-size: 12px; color: #FFD700; margin-top: 5px;">ğŸ’¡ é›™æ“Š=å¤§çµ•(1.5å€å‚·) | é•·æŒ‰=é˜²ç¦¦</div>
    </div>
    
    <div id="loadingScreen">
        <h1>è³‡æºè¼‰å…¥ä¸­...</h1>
    </div>

    <div id="startScreen">
        <h1 style="font-size: 40px; color: #FFD700; text-shadow: 2px 2px #000;">å°é«˜éº—å¤§æˆ°ç²½å­</h1>
        <p>æ‰“å€’ç²½å­è»åœ˜èˆ‡é­”ç‹ï¼</p>
        <button onclick="startGame()">é–‹å§‹éŠæˆ²</button>
    </div>

    <div id="bossWarning">âš ï¸ é­”ç‹ä¾†è¥² âš ï¸</div>
    <div id="skillContainer"></div>

    <canvas id="gameCanvas" width="800" height="500"></canvas>
    
    <div id="controls">
        <div class="control-group">
            <div class="btn" id="btn-up" data-key="ArrowUp">â†‘</div>
            <div class="btn" id="btn-down" data-key="ArrowDown">â†“</div>
            <div class="btn" id="btn-left" data-key="ArrowLeft">â†</div>
            <div class="btn" id="btn-right" data-key="ArrowRight">â†’</div>
        </div>
        <div class="control-group">
            <div class="btn" id="btn-fire" data-key="Space"></div>
        </div>
    </div>

    <div id="gameOverScreen">
        <h1 id="endTitle">éŠæˆ²çµæŸ</h1>
        <p>åˆ†æ•¸: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">é‡ä¾†</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const nextLevelEl = document.getElementById('nextLevel');
    const hpDisplayEl = document.getElementById('hpDisplay');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const startScreen = document.getElementById('startScreen');
    const loadingScreen = document.getElementById('loadingScreen');
    const endTitle = document.getElementById('endTitle');
    const finalScoreEl = document.getElementById('finalScore');
    const bossWarningEl = document.getElementById('bossWarning');
    const skillContainer = document.getElementById('skillContainer');
    const btnFire = document.getElementById('btn-fire');
    const uiEl = document.getElementById('ui');
    const controlsEl = document.getElementById('controls');

    // --- åœ–ç‰‡è¼‰å…¥ ---
    const BASE_URL = 'https://raw.githubusercontent.com/putsuketsu-dev/Cabbage/main/';
    const imageSources = {
        background: BASE_URL + 'BG.jpg', 
        playerRun1: BASE_URL + 'ä¸»è§’èµ°è·¯1.png',
        playerRun2: BASE_URL + 'ä¸»è§’èµ°è·¯2.png',
        playerAttack: BASE_URL + 'ä¸»è§’æ”»æ“Š.png',
        playerBullet: BASE_URL + 'ä¸»è§’æ‹›å¼.png',
        boss1: BASE_URL + 'é­”ç‹1.png',
        boss2: BASE_URL + 'é­”ç‹2.png',
        bossUltAnim: BASE_URL + 'é­”ç‹é–‹å¤§çµ•.png',
        bossUltBullet: BASE_URL + 'é­”ç‹å¤§çµ•æ‹›.png',
        minion: BASE_URL + 'å°æ€ª.png',
        smallBoss: BASE_URL + 'å°ç‹.png',
        superMove: BASE_URL + 'skill.png',
        bossThrow: BASE_URL + 'bthrow.png' 
    };

    const images = {};
    const imageLoaded = {};
    let imagesToLoad = Object.keys(imageSources).length;
    let imagesLoadedCount = 0;

    function imageLoadHandler(key) {
        imageLoaded[key] = true;
        imagesLoadedCount++;
        if(key === 'playerBullet') {
            btnFire.style.setProperty('--icon-url', `url('${imageSources[key]}')`);
        }
        // æ‰€æœ‰åœ–ç‰‡å˜—è©¦è¼‰å…¥å¾Œ(ç„¡è«–æˆåŠŸå¤±æ•—)ï¼Œé€²å…¥æº–å‚™ç‹€æ…‹
        if (imagesLoadedCount === imagesToLoad) {
            loadingScreen.style.display = 'none';
            startScreen.style.display = 'flex';
        }
    }

    for (let key in imageSources) {
        images[key] = new Image();
        images[key].crossOrigin = "Anonymous";
        images[key].onload = () => imageLoadHandler(key);
        images[key].onerror = () => {
            console.error("Image load failed: " + key);
            imageLoadHandler(key); 
        };
        images[key].src = imageSources[key];
    }

    function drawSprite(imgKey, x, y, w, h, fallbackColor, shape='rect', sourceX=0, sourceY=0, sourceW=0, sourceH=0) {
        if (imageLoaded[imgKey]) {
            try {
                if (sourceW > 0 && sourceH > 0) { 
                    ctx.drawImage(images[imgKey], sourceX, sourceY, sourceW, sourceH, x, y, w, h);
                } else {
                    ctx.drawImage(images[imgKey], x, y, w, h);
                }
            } catch(e) {
                drawShape(fallbackColor, x, y, w, h, shape);
            }
        } else {
            drawShape(fallbackColor, x, y, w, h, shape);
        }
    }

    function drawShape(color, x, y, w, h, shape) {
        ctx.fillStyle = color;
        if (shape === 'circle') {
            ctx.beginPath(); ctx.arc(x + w/2, y + h/2, w/2, 0, Math.PI * 2); ctx.fill();
        } else {
            ctx.fillRect(x, y, w, h);
        }
        ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.strokeRect(x, y, w, h);
    }

    // --- éŠæˆ²åƒæ•¸ ---
    let gameRunning = false;
    let frameCount = 0;
    let score = 0;
    let level = 1;
    const ENEMIES_PER_LEVEL = 20; 
    let enemiesDefeatedInLevel = 0;
    let bossActive = false;
    let bossSpawned = false;
    let pendingLevelUp = false;

    let backgroundOffsetX = 0;
    const targetBackgroundSourceX = 800; 
    const backgroundScrollSpeed = 16; 
    let scrollingBackground = false;
    let currentBackgroundSourceX = 0;

    // è§’è‰²
    const player = {
        x: 50, y: 250, width: 160, height: 160, speed: 6, hp: 5, maxHp: 5,
        isInvincible: false, invincibleTimer: 0, isAttacking: false, attackTimer: 0,
        isDefending: false, defenseTimer: 0, charge: 0, maxCharge: 10,
        isStunned: false, stunTimer: 0 // æ–°å¢æšˆçœ©å±¬æ€§
    };

    let bullets = [];
    let bossBullets = [];
    let enemies = [];
    let items = []; 
    let combatTexts = []; 
    let enemySpawnRate = 60;

    const bossQuotes = ["è¦åŠ é†¬å—ï¼Ÿ", "æ²’æœ‰åƒç´ é½", "ç¾åœ¨åƒå—ï¼Ÿ"];
    let bossText = { text: "", timer: 0, x: 0, y: 0 };

    // --- æ§åˆ¶ç³»çµ± ---
    const keys = {};
    let fireKeyPressed = false;
    let fireKeyTimer = 0;
    let lastFireReleaseTime = 0;

    window.addEventListener('keydown', (e) => {
        if (!gameRunning) return;
        keys[e.code] = true;
        if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
        if (e.code === 'Space' && !fireKeyPressed) {
            fireKeyPressed = true;
            handleFirePress();
        }
    });
    window.addEventListener('keyup', (e) => {
        if (!gameRunning) return;
        keys[e.code] = false;
        if (e.code === 'Space') {
            fireKeyPressed = false;
            handleFireRelease();
        }
    });

    const btns = document.querySelectorAll('.btn');
    btns.forEach(btn => {
        const handleStart = (e) => {
            if (!gameRunning) return;
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = true;
            btn.classList.add('pressed');
            if (key === 'Space' && !fireKeyPressed) {
                fireKeyPressed = true;
                handleFirePress();
            }
        };
        const handleEnd = (e) => {
            if (!gameRunning) return;
            e.preventDefault();
            const key = btn.getAttribute('data-key');
            keys[key] = false;
            btn.classList.remove('pressed');
            if (key === 'Space') {
                fireKeyPressed = false;
                handleFireRelease();
            }
        };
        btn.addEventListener('touchstart', handleStart);
        btn.addEventListener('touchend', handleEnd);
        btn.addEventListener('mousedown', handleStart);
        btn.addEventListener('mouseup', handleEnd);
    });

    function handleFirePress() {
        if (player.isStunned) return; // æšˆçœ©æ™‚ç„¡æ³•å‹•ä½œ

        fireKeyTimer = 0;
        let currentTime = new Date().getTime();
        if (currentTime - lastFireReleaseTime < 300 && player.charge >= player.maxCharge) {
            fireSuperMove(); 
            player.isDefending = false; 
            fireKeyTimer = 999; 
        }
    }

    function handleFireRelease() {
        if (player.isStunned) return; // æšˆçœ©æ™‚ç„¡æ³•å‹•ä½œ

        lastFireReleaseTime = new Date().getTime();
        if (fireKeyTimer < 15) { 
            shoot(); 
            player.isAttacking = true;
            player.attackTimer = 15;
        }
        player.isDefending = false;
        fireKeyTimer = 0;
    }

    function addCharge() {
        if (player.charge < player.maxCharge) {
            player.charge++;
            updateChargeUI();
        }
    }

    function updateChargeUI() {
        const pct = (player.charge / player.maxCharge) * 100;
        btnFire.style.setProperty('--progress', pct + '%');
        if (player.charge >= player.maxCharge) {
            btnFire.classList.add('charged');
        } else {
            btnFire.classList.remove('charged');
        }
    }

    function fireSuperMove() {
        player.charge = 0; 
        updateChargeUI();
        showSkillText("å°é«˜éº—çš„åˆ¶è£ï¼", player.x, player.y - 50);
        
        bullets.push({
            x: player.x + player.width, 
            y: player.y + player.height / 2 - 75, 
            vx: 15, vy: 0,
            width: 300, height: 150, 
            type: 'super', 
            damage: 1.5, 
            piercing: true, 
            life: 100
        });
    }

    function showSkillText(text, x, y) {
        const el = document.createElement('div');
        el.innerText = text;
        el.className = 'skill-text';
        let safeX = Math.min(Math.max(x, 50), 600);
        el.style.left = safeX + 'px';
        el.style.top = '150px'; 
        skillContainer.appendChild(el);
        setTimeout(() => el.remove(), 1500);
    }

    function showCombatText(text, x, y, color="#FFF") {
        combatTexts.push({
            text: text, x: x, y: y, color: color, life: 30
        });
    }

    function shoot() {
        if(player.isDefending) return; 

        let bulletCount = 1;
        if (level === 2) bulletCount = 3;
        if (level >= 3) bulletCount = 5; 
        let baseSpeed = 12 + (level * 1.5);
        
        const bulletSize = 80 * 1.3; 

        for (let i = 0; i < bulletCount; i++) {
            let vy = 0;
            if (bulletCount > 1) {
                let spreadFactor = 1.5;
                let centerIndex = (bulletCount - 1) / 2;
                vy = (i - centerIndex) * spreadFactor;
            }
            bullets.push({
                x: player.x + player.width - 30, 
                y: player.y + player.height / 2,
                vx: baseSpeed, vy: vy,
                size: bulletSize, 
                color: '#FFFF00',
                damage: 1,
                type: 'normal'
            });
        }
    }

    function playerTakeDamage(damage, options={}) {
        if (player.isDefending) {
            player.isInvincible = true;
            player.invincibleTimer = 10; 
            showCombatText("é˜²ç¦¦!", player.x + 50, player.y, "#00BFFF");
            return; 
        }

        if (player.isInvincible || !gameRunning) return;

        // æšˆçœ©åˆ¤å®šï¼šå¦‚æœè¢«æ¨™è¨˜ç‚º isUltimate çš„æ”»æ“Šæ‰“ä¸­ï¼Œä¸”æ²’æœ‰é˜²ç¦¦
        if (options.isUltimate) {
            player.isStunned = true;
            player.stunTimer = 90; // æšˆçœ© 1.5 ç§’
            showCombatText("æšˆçœ©!", player.x + 50, player.y - 30, "orange");
        }

        player.hp -= damage;
        updateHPUI();
        if (player.hp <= 0) {
            gameOver("è¢«ç²½å­å¡é£½äº†...");
        } else {
            player.isInvincible = true;
            player.invincibleTimer = 90; 
        }
    }

    function updateHPUI() {
        let hearts = "";
        for(let i=0; i<player.hp; i++) hearts += "â¤ï¸";
        for(let i=player.hp; i<player.maxHp; i++) hearts += "ğŸ–¤"; 
        hpDisplayEl.innerText = hearts;
    }

    function bossSpeak(x, y) {
        const text = bossQuotes[Math.floor(Math.random() * bossQuotes.length)];
        bossText.text = text;
        bossText.timer = 120; 
        bossText.x = x;
        bossText.y = y - 60;
    }

    function bossAttack(boss) {
        const bossBulletSize = 30 * 1.2; 

        if (boss.phase === 1) {
            if (frameCount % 120 === 0) { 
                bossSpeak(boss.x, boss.y);
                for(let i = -1; i <= 1; i++) {
                    let dx = player.x - boss.x;
                    let dy = player.y - boss.y;
                    let angle = Math.atan2(dy, dx);
                    bossBullets.push({
                        x: boss.x + boss.width / 2, y: boss.y + boss.height / 2,
                        vx: Math.cos(angle + i * 0.25) * 6, vy: Math.sin(angle + i * 0.25) * 6,
                        size: bossBulletSize, 
                        type: 'normal'
                    });
                }
            }
            if (boss.hp <= boss.maxHp * 0.2 && !boss.hasUlted) {
                boss.hasUlted = true; fireUltimate(boss);
            }
        } else if (boss.phase === 2) {
            if (frameCount % 90 === 0) {
                bossSpeak(boss.x, boss.y);
                fireUltimate(boss);
            }
        }
    }

    function fireUltimate(boss) {
        showSkillText("æ’éšŠæ“‹è·¯ï¼", boss.x - 50, boss.y - 50);
        
        boss.isCasting = true;
        setTimeout(() => boss.isCasting = false, 1500);

        bossBullets.push({
            x: boss.x - 50, y: boss.y, 
            vx: -6, vy: 0, size: 140, 
            type: 'ultimate', rotation: 0, homing: true
        });
    }

    function spawnEnemy() {
        if (bossActive || pendingLevelUp || scrollingBackground) return; 

        let enemyType = 'minion';
        let eWidth = 110; let eHeight = 110; 
        let eHp = 1 + Math.floor(level / 1.5);
        
        if (level === 2) {
            if (Math.random() < 0.4) {
                enemyType = 'smallBoss'; 
                eWidth = 130; eHeight = 130; 
                eHp = 8; // å°ç‹è¡€é‡
            }
        }
        enemies.push({
            x: 800, y: 300 + Math.random() * 120, 
            width: eWidth, height: eHeight,
            speed: enemyType === 'smallBoss' ? 2 : 3 + (level * 0.8),
            hp: eHp, type: enemyType, maxHp: eHp
        });
    }

    function triggerBossStage() {
        bossActive = true;
        bossSpawned = false; 
        enemies = []; 
        scrollingBackground = true; 
        updateUI();
    }

    function realSpawnBoss() {
        bossActive = true; 
        bossSpawned = true; 
        scrollingBackground = false; 
        currentBackgroundSourceX = targetBackgroundSourceX; 

        bossWarningEl.style.display = 'block';
        setTimeout(() => bossWarningEl.style.display = 'none', 3000);

        enemies.push({
            x: 800 - 250, y: 250,
            width: 240, height: 240, 
            speed: 2, hp: 100, maxHp: 100,
            type: 'boss', phase: 1, moveDir: -1, hasUlted: false,
            isCasting: false 
        });
        updateUI();
    }

    function evolveBoss(boss) {
        bossWarningEl.innerText = "âš ï¸ æœ€çµ‚å½¢æ…‹é€²åŒ–!!! âš ï¸";
        bossWarningEl.style.display = 'block';
        setTimeout(() => bossWarningEl.style.display = 'none', 2000);
        boss.phase = 2; boss.hp = 150; boss.maxHp = 150;
        boss.width = 240; boss.height = 240; boss.y = 250; 
        boss.isCasting = false; 
    }

    function update() {
        if (!gameRunning) { 
            requestAnimationFrame(draw);
            return;
        }

        // --- æ§åˆ¶èˆ‡ç‹€æ…‹æ›´æ–° ---
        
        // æšˆçœ©é‚è¼¯
        if (player.isStunned) {
            player.stunTimer--;
            // æšˆçœ©æ™‚ç„¡æ³•æ“ä½œ
            player.isDefending = false;
            player.isAttacking = false;
            if (player.stunTimer <= 0) {
                player.isStunned = false;
                // é‡ç½®æŒ‰éµç‹€æ…‹é¿å…é€£ç™¼
                fireKeyTimer = 0;
                fireKeyPressed = false;
            }
        } 
        else {
            // æ­£å¸¸æ§åˆ¶é‚è¼¯
            if (fireKeyPressed) {
                fireKeyTimer++;
                if (fireKeyTimer >= 15) { 
                    player.isDefending = true; 
                    player.isAttacking = false;
                }
            }

            if (player.isAttacking) {
                player.attackTimer--;
                if (player.attackTimer <= 0) player.isAttacking = false;
            }
            
            // ç§»å‹•
            let isMoving = false;
            if (keys['ArrowUp'] && player.y > 0) { player.y -= player.speed; isMoving = true; }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) { player.y += player.speed; isMoving = true; }
            if (keys['ArrowLeft'] && player.x > 0) { player.x -= player.speed; isMoving = true; }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) { player.x += player.speed; isMoving = true; }
            
            player.isMoving = isMoving; 
        }

        if (player.isInvincible) {
            player.invincibleTimer--;
            if (player.invincibleTimer <= 0) player.isInvincible = false;
        }
        
        if (bossText.timer > 0) bossText.timer--;
        if (pendingLevelUp) { performLevelUp(); pendingLevelUp = false; }
        
        if (!bossActive && !pendingLevelUp && !scrollingBackground) {
            if (frameCount % enemySpawnRate === 0) spawnEnemy();
            enemySpawnRate = Math.max(10, 45 - (level * 12)); 
        }

        if (scrollingBackground) {
             if (currentBackgroundSourceX < targetBackgroundSourceX) {
                currentBackgroundSourceX = Math.min(currentBackgroundSourceX + backgroundScrollSpeed, targetBackgroundSourceX);
            } else {
                realSpawnBoss();
            }
        } else if (!bossActive && currentBackgroundSourceX > 0) {
             currentBackgroundSourceX = Math.max(currentBackgroundSourceX - backgroundScrollSpeed, 0);
        }

        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.x -= item.speed; 
            if (checkRectCollision(player, item)) {
                if (item.type === 'heart') {
                    if(player.hp < player.maxHp) { player.hp++; updateHPUI(); }
                }
                items.splice(i, 1); continue;
            }
            if (item.x < -50) items.splice(i, 1);
        }

        for(let i = combatTexts.length - 1; i >= 0; i--) {
            let t = combatTexts[i];
            t.y -= 1; t.life--;
            if(t.life <= 0) combatTexts.splice(i, 1);
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx; b.y += b.vy; 
            if (b.type !== 'super' && (b.x > canvas.width || b.y < 0 || b.y > canvas.height)) {
                bullets.splice(i, 1);
            } else if (b.type === 'super') {
                b.life--;
                if (b.life <= 0 || b.x > canvas.width) bullets.splice(i, 1);
            }
        }

        for (let i = bossBullets.length - 1; i >= 0; i--) {
            let b = bossBullets[i];
            b.x += b.vx; b.y += b.vy;
            if (b.type === 'ultimate') {
                b.rotation -= 0.2;
                if (b.homing) {
                    let dy = player.y - b.y;
                    if (dy > 0) b.vy += 0.15; else b.vy -= 0.15;
                    if (b.vy > 3) b.vy = 3; if (b.vy < -3) b.vy = -3;
                }
            }
            let hitBoxSize = b.type === 'ultimate' ? b.size * 0.7 : b.size * 0.8; 
            if (checkRectCollision(
                {x: b.x - hitBoxSize/2, y: b.y - hitBoxSize/2, width: hitBoxSize, height: hitBoxSize},
                {x: player.x + 10, y: player.y + 10, width: player.width - 20, height: player.height - 20}
            )) {
                // åˆ¤æ–·æ˜¯å¦ç‚ºå¤§çµ•æ‹›æ”»æ“Š
                let isUltimate = (b.type === 'ultimate');
                playerTakeDamage(1, {isUltimate: isUltimate});
                
                if (b.type !== 'ultimate') bossBullets.splice(i, 1);
            }
            if (b.x < -200 || b.y < -100 || b.y > canvas.height + 100) bossBullets.splice(i, 1);
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (e.type === 'boss') {
                if (e.x > canvas.width - 250) e.x -= e.speed;
                let moveSpeed = e.phase === 2 ? e.speed * 2 : e.speed;
                e.y += moveSpeed * e.moveDir;
                if (e.y < 250 || e.y > 350) e.moveDir *= -1;
                bossAttack(e);
                bossText.x = e.x; bossText.y = e.y - 60; 
            } else { e.x -= e.speed; }

            for (let j = bullets.length - 1; j >= 0; j--) {
                let b = bullets[j];
                
                let bRect = b.type === 'super' 
                    ? {x: b.x, y: b.y, width: b.width, height: b.height} 
                    : {x: b.x - b.size/2 + b.size*0.1, y: b.y - b.size/2 + b.size*0.1, width: b.size * 0.8, height: b.size * 0.8}; 

                let eRect = {x: e.x + 10, y: e.y + 10, width: e.width - 20, height: e.height - 20};

                if (checkRectCollision(bRect, eRect)) {
                    
                    let defenseChance = (e.type === 'boss' && b.type === 'super') ? 0.6 : 0.3; 
                    
                    if (e.type === 'boss' && Math.random() < defenseChance) {
                        showCombatText("é˜²ç¦¦!", e.x + e.width/2, e.y, "#00FFFF");
                        if (!b.piercing) bullets.splice(j, 1);
                    } else {
                        e.hp -= (b.damage || 1);
                        if (e.type === 'boss') addCharge(); 
                        if (!b.piercing) bullets.splice(j, 1);

                        if (e.hp <= 0) {
                            if (e.type === 'boss') {
                                if (e.phase === 1) evolveBoss(e); else gameWin();
                            } else {
                                addCharge();
                                if (e.type === 'smallBoss' && Math.random() < 0.5) spawnItem(e.x, e.y);
                                score += 10; enemiesDefeatedInLevel++;
                                
                                if (enemiesDefeatedInLevel >= ENEMIES_PER_LEVEL && enemies.length === 1) { 
                                    pendingLevelUp = true;
                                }

                                enemies.splice(i, 1);
                                break; 
                            }
                            updateUI();
                        }
                    }
                    if (!b.piercing) break; 
                }
            }
            
            if (gameRunning && enemies[i]) {
                if (checkRectCollision(
                    {x: e.x + 10, y: e.y + 10, width: e.width - 20, height: e.height - 20},
                    {x: player.x + 10, y: player.y + 10, width: player.width - 20, height: player.height - 20}
                )) {
                    playerTakeDamage(1);
                    if(e.type !== 'boss') enemies.splice(i, 1);
                }
            }
            if (enemies[i] && enemies[i].x + enemies[i].width < 0) enemies.splice(i, 1);
        }

        frameCount++;
        requestAnimationFrame(draw);
        requestAnimationFrame(update);
    }
    
    function checkRectCollision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
    }

    function spawnItem(x, y) {
        items.push({
            x: x, y: y, width: 40, height: 40, speed: 2, type: 'heart' 
        });
    }

    function performLevelUp() { 
        if (level === 1) {
             level++; 
             enemiesDefeatedInLevel = 0; 
        } else if (level === 2) {
            level++;
            triggerBossStage();
            return;
        } else if (level > 2) {
            level++;
            enemiesDefeatedInLevel = 0; 
            if (player.hp < player.maxHp) player.hp++; updateHPUI(); 
        }
        updateUI(); 
    }

    function updateUI() {
        scoreEl.innerText = score; updateHPUI();
        if (bossActive) {
            if (bossSpawned) {
                if (enemies.length > 0 && enemies[0].phase === 2) { levelEl.innerText = "FINAL"; nextLevelEl.innerText = "æ´»ä¸‹å»"; }
                else { levelEl.innerText = "BOSS"; nextLevelEl.innerText = "æ‰“å€’ä»–"; }
            } else { levelEl.innerText = "WARN"; nextLevelEl.innerText = "æ¥è¿‘ä¸­..."; }
        } else { levelEl.innerText = level; nextLevelEl.innerText = "é‚„éœ€: " + (ENEMIES_PER_LEVEL - enemiesDefeatedInLevel); }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        if (imageLoaded['background']) {
            try {
                ctx.drawImage(
                    images['background'], 
                    0, 0, 1600, 500, 
                    -currentBackgroundSourceX, 0, 1600, 500
                );
            } catch(e) {
                drawFallbackBackground();
            }
        } else {
            drawFallbackBackground();
        }
        
        if (bossText.timer > 0) {
            ctx.font = "bold 24px Arial";
            ctx.fillStyle = "white"; ctx.strokeStyle = "black"; ctx.lineWidth = 3; ctx.textAlign = "center";
            ctx.strokeText(bossText.text, bossText.x + 90, bossText.y);
            ctx.fillText(bossText.text, bossText.x + 90, bossText.y);
        }

        if (!player.isInvincible || Math.floor(frameCount / 5) % 2 === 0) {
            let imgKey;
            
            if (player.isAttacking) {
                imgKey = 'playerAttack';
            } else if (player.isMoving || (bossActive && !bossSpawned)) { // [ä¿®æ­£] è½‰å ´æ™‚å¼·åˆ¶æ’­æ”¾èµ°è·¯å‹•ç•«
                imgKey = (Math.floor(frameCount / 8) % 2 === 0) ? 'playerRun1' : 'playerRun2';
            } else {
                imgKey = 'playerRun1'; 
            }

            // æšˆçœ©ç‰¹æ•ˆï¼šè®Šç° + é ­é ‚ç¬¦è™Ÿ
            if (player.isStunned) {
                ctx.save();
                ctx.filter = 'grayscale(100%)';
                drawSprite(imgKey, player.x, player.y, player.width, player.height, '#32CD32');
                ctx.restore();
                ctx.font = "30px Arial";
                ctx.fillText("ğŸ’«", player.x + player.width/2, player.y - 20);
            } else {
                drawSprite(imgKey, player.x, player.y, player.width, player.height, '#32CD32'); 
            }
            
            if (player.isDefending) {
                ctx.beginPath();
                ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/1.5, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(0, 191, 255, 0.4)"; ctx.fill();
                ctx.strokeStyle = "#00BFFF"; ctx.lineWidth = 3; ctx.stroke();
            }
        }
        
        for (let item of items) {
            ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText("â¤ï¸", item.x + item.width/2, item.y + item.height/2);
        }

        for (let b of bullets) {
            if (b.type === 'super') {
                drawSprite('superMove', b.x, b.y, b.width, b.height, '#00FFFF', 'rect');
            } else {
                drawSprite('playerBullet', b.x - b.size/2, b.y - b.size/2, b.size, b.size, '#FFFF00', 'circle');
            }
        }
        
        for (let b of bossBullets) {
            if (b.type === 'ultimate') {
                ctx.save(); ctx.translate(b.x, b.y); ctx.rotate(b.rotation);
                drawSprite('bossUltBullet', -b.size/2, -b.size/2, b.size, b.size, '#8B0000');
                ctx.restore();
            } else {
                drawSprite('minion', b.x - b.size/2, b.y - b.size/2, b.size, b.size, '#A52A2A');
            }
        }
        
        for (let e of enemies) {
            if (e.type === 'boss') {
                let shake = (e.phase === 2) ? (Math.random() * 6 - 3) : 0;
                let imgKey;
                
                if (e.isCasting && imageLoaded['bossThrow']) { 
                    imgKey = 'bossThrow'; 
                } else if (e.phase === 1) { 
                    imgKey = (Math.floor(frameCount / 15) % 2 === 0) ? 'boss1' : 'boss2'; 
                } else { 
                    imgKey = 'bossUltAnim'; 
                }

                drawSprite(imgKey, e.x + shake, e.y, e.width, e.height, '#800080');
                
                ctx.fillStyle = "white"; ctx.fillRect(e.x, e.y - 30, e.width, 15);
                ctx.fillStyle = e.phase === 2 ? "#800080" : (e.hp <= e.maxHp * 0.3 ? "red" : "orange");
                ctx.fillRect(e.x + 2, e.y - 28, (e.width - 4) * (e.hp / e.maxHp), 11);
            } else if (e.type === 'smallBoss') {
                drawSprite('smallBoss', e.x, e.y, e.width, e.height, '#FF0000');
                ctx.fillStyle = "red"; ctx.fillRect(e.x, e.y - 10, e.width * (e.hp/e.maxHp), 5);
            } else {
                drawSprite('minion', e.x, e.y, e.width, e.height, '#696969');
            }
        }

        for (let t of combatTexts) {
            ctx.font = "bold 20px Arial";
            ctx.fillStyle = t.color;
            ctx.textAlign = "center";
            ctx.fillText(t.text, t.x, t.y);
        }
    }

    function drawFallbackBackground() {
        ctx.fillStyle = '#87CEEB'; 
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 2;
        let offset = currentBackgroundSourceX % 100; 
        for(let i=offset; i<canvas.width; i+=100) {
            ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
        }
    }

    function startGame() {
        startScreen.style.display = 'none';
        uiEl.style.display = 'block';
        controlsEl.style.display = 'flex';
        restartGame();
    }

    function gameOver(reason) {
        gameRunning = false; endTitle.innerText = reason; finalScoreEl.innerText = score;
        gameOverScreen.style.display = 'block';
    }
    function gameWin() {
        gameRunning = false; endTitle.innerText = "ğŸ† å‚³å¥‡èª•ç”Ÿï¼"; finalScoreEl.innerText = score + 10000;
        gameOverScreen.style.display = 'block';
    }
    function restartGame() {
        score = 0; level = 1; enemiesDefeatedInLevel = 0; bossActive = false; pendingLevelUp = false; bossSpawned = false;
        enemies = []; bullets = []; bossBullets = []; items = []; combatTexts = [];
        player.y = 250; player.x = 50; player.hp = player.maxHp; player.isInvincible = false;
        player.isAttacking = false; player.isDefending = false; player.attackTimer = 0; player.charge = 0;
        player.isStunned = false; player.guardHitCount = 0;
        enemySpawnRate = 60; 
        currentBackgroundSourceX = 0; 
        scrollingBackground = false;
        gameRunning = true; gameOverScreen.style.display = 'none'; bossWarningEl.style.display = 'none';
        skillContainer.innerHTML = ''; updateUI(); updateChargeUI(); 
        
        // ç¢ºä¿ loop åªæœ‰ä¸€å€‹åœ¨è·‘
        // requestAnimationFrame(update); // ç§»é™¤é€™è£¡çš„èª¿ç”¨ï¼Œä¾è³´ startGame æˆ–ä¸»å…¥å£
    }

    // å•Ÿå‹•éŠæˆ²ä¸»å¾ªç’°
    requestAnimationFrame(update);
</script>

</body>
</html>
